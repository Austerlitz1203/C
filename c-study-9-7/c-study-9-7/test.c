#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
struct stu
{
	int a[5];
}*p;
int main()
{
//	int a[3][4] = { 0 };  //二维数组理解，想象成一维数组，他的首元素就是第一行，a就是第一行的地址
//	
//	
//	printf("%d\n", sizeof(a));//48 a是二维数组的数组名，单独放在sizeof内部，所以返回整个数组总大小
//	printf("%d\n", sizeof(a[0][0]));
//	printf("%d\n", sizeof(a[0]));//a[0]表示的是第一行的数组名，因为a[0][j]表示的是第0行第j个，所以计算的是一行数组的大小
//                               //把二维数组看作一维数组的时候，a[0]是第一行的数组名，数组名单独放在sizeof内部……	
//	                           //和前面类似，它和二维数组的地址，再值上是一样，但是含义不同
//	printf("%d\n", sizeof(a[0]+1));//a[0]虽然是第一行的数组名，但是并非单独放在sizeof内部，考虑到a[0]是第一行的数组名
//	                             //但是就和一维数组一样，数组名并非表示整个第一行，数组名是首元素地址，
//	                            // +1是后一个元素地址,a[0]可以看作 &a[0][0]，a[0]+1是&a[0][1]
//	
//	printf("%d\n", sizeof(*(a[0]+1)));//自然是4了
//	printf("%d\n", sizeof(a+1));//a是二维数组数组名，a表示首元素地址，那么就是第一行的地址，+1是跳过一行，表示的是
//	                          //第二行的地址，地址是4/8，（a+1既不是单独放在sizeof内，又不是&）
//	printf("%d\n", sizeof(*(a+1)));//a+1是第二行的地址，对其解引用是第二行的大小（对char类型解引用是1，int是4……）
//	printf("%d\n", sizeof(&a[0]+1)); //a[0]是第一行数组名，&a[0]自然是第一行一整行地址，+1是第二行地址，地址是4/8
//	printf("%d\n", sizeof(*(&a[0] + 1)));
//	printf("%d\n", sizeof(*a));
//	printf("%d\n", sizeof(a[3]));//这里代码其实没问题，a[3]是二维数组第四行，虽然定义上没有第四行，但是类型确定了大小就确定
//	//sizeof是根据类型来判断大小，不需要去访问值，比如下面例子
//    //可以分析出a[3]类型是，int [][4],知道类型就可以知道大小
//	//任何一个表达式都有两个属性：
//	//3+5
//	//值属性：8
//	//类型属性：int
//	short num = 20;
//	int b = 4;
//	printf("%d\n", sizeof(num = b + 5));
//	printf("%d\n", num);
//	//项目要经过 编译  ――  链接 ――运行  三个过程
//	//sizeof()内部不计算的原因是，sizeof表达式是在编译期间处理的，这个时候变量还没有创建


	//int  a[5] = { 1,2,3,4,5 };
	//int* ptr = (int*)(&a+1);
	//printf("%d   %d", *(a + 1), *(ptr - 1));
	////a是数组名，表示首元素地址，a+1是2的地址
	////ptr是int* 类型的指针，所以一次跳过一个整形，即四个字节，而&a是整个数组地址，+1是跳过整个数组，强制类型转换
	////成int*，-1之后是退后四个字节，表示的是5的地址

	//p = (struct stu*)0x100000;
	//printf("%p\n", p + 0x1);//这里结构体指针+1，跳过一个结构体长度,20个字节，十六进制就是0x100014
	//printf("%p\n", (unsigned long)p + 0x1);//注意，这里是强制类型转换成long，是一个整形，不是指针，+1就是+1
	//printf("%p\n", (unsigned int *)p + 0x1);//这里强制类型转换成int*类型，所以+1是跳过4个字节

	//int a[4] = { 1,2,3,4 };
	//int *ptr = (int*)((int)a + 1);
	//printf("%x", *ptr);
	//假设a地址是0x000015，强制类型转换成int就是代表21，21+1就是22，在转换成int*就是0x000016
	//所以实际上ptr是a的地址向后一个字节的地址
	//0x00000001
	//0x00000002
    //小端存储就是：
	//01 00 00 00 02 00 00 00 
	//所以实际上ptr是指向01后面的00，如何拿四个字节，又因为是小端，所以地址是0x02000000
	//打印地址不会打印0x和开头的0，所以直接打印2000000



	//int  a[3][2] = { (1,2),(3,4),(5,6) };//逗号表达式，实际上只有a[0][0]=2，a[0][1]=4，a[1][0]=6
	//int* p = a[0];//a[0]是第一行的数组名，指针来看是第一行首元素地址，所以*p就是2
	//printf("%d", *p);



	//int a[5][5];
	//int(*p)[4]=a;//p是指向有四个整形的数组的指针，所以p+1是跳过四个整形元素
	//printf("%p  %d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	////指针和指针相减得到的是两个指针相隔的数据个数，前面的改成地址打印，就是16进制，因为内存里存的是补码，
	////所以-4的补码化成16进制即可，就是%p格式打印的结果


	//int a[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
	//int* ptr = (int*)(*(a + 1));  //*(a+1) 相当于a[1]，理解为第二行的数组名，数组名就是首元素地址，就是6的地址
	//printf("%d", *(ptr - 1));
	////这里a+1是第二行的地址，实际上值是6的地址，但是含义是第二行地址，所以*后int*再-1是5的地址


	char* arr[] = { "work","at","alibaba" };
	char** p = arr;
	p++;
	printf("%s\n", *p);
	return 0;
}