//realloc调整动态开辟内存的大小
#include<stdio.h>
#include<stdlib.h>
#include<error.h>
#include<string.h>
//int main()
//{
//    int *p=(int*)malloc(20);//20个字节的空间
//    if (p == NULL)
//        printf("%s\n",strerror(errno));
//    //这里必须要有，因为如果malloc失败，p会被赋值为空指针，后续操作时非法的
//    else
//    {
//        int i=0;
//        for(i=0;i<5;i++)
//            *(p+i)=i;
//    }
//    //假设这里20个字节不能满足使用要求
//    //希望能够有四十个字节的空间
//    //可以用relloc来调整动态分布的内存
//    int* p2=realloc(p,40);
//    //可以p2换成p，但是有风险，如果原空间后面足够多，那么直接在后面开辟
//    //返回地址还是和原地址一样
//    //如果新开辟的空间在原空间后面放不下，要新
//    //开辟一个空间，那么返回的地址和原地址p不同，
//    //依然用p接收的话，p会发生变化，所以用另外的指针更好
//    for (int i=0;i<10;i++)
//        printf("%d  ",*(p2+i));
//    free(p);
//    p=NULL;
//    return 0;
//}

//realloc使用的注意事项:
//1.如果p指向的空间之后有足够的内存空间可以追加,则直接追加,后返回p
//2..如果p指向的空间之后没有足够的内存空间可以追加，则realloc函数会
//重新找一个新的内存区域/开辟一块满足需求的空间,并且把原来内存中
//的数据拷贝回来,释放旧的内存空间，最后返回新开壁的内存空间地址
//3。得用一个新的变量来接受realIoc函数的返回值

//不能越界访问，就是说，开辟了5个int类型空间（20个字节），但是
//对其赋值的时候，赋值了超过5个int类型，这时候运行会崩溃

//int main()
//{
//    int a=20;
//    int* p;
//    p=&a;
//    *p=30;
//    free(p);
//    p=NULL;
//}
//
//这样极其错误，C语言内存分为三个区域
//静态区，全局变量存储
//栈区，局部变量存储
//堆区，动态存储，malloc等在这里面开辟，free也是对块区域内存释放
//上面代码，a是在栈区开辟，p指向a，指向栈区，却要释放p
//而free只能释放堆区，所以错误，程序死了
//可以理解为只有malloc，realloc等才可以free

//int main()
//{
//    int *p=(int*)malloc(40);
//    if (p==NULL)
//        printf("wrong");
//    else
//    {
//        for (int i=0;i<10;i++)
//            *p++ = i;
//    }
//    free(p);
//    p=NULL;
//    return 0;
//}
//free不能只释放开辟的空间的一部分
//这样也会死
//因为p++,for 结束之后，p的位置已经跑到开辟内存最后面，无法释放后面的空间
//free只能从开辟的空间的起始位置释放

//也不能对同一块动态内存多次释放
//避免方法，如上，free后把空指针赋给p；空指针无法释放


//内存泄漏，  开辟了空间忘了释放
//同时要注意避免以下写法
//test()
//{
//    int *p=(int *)malloc(100);
//    //……
//}
//int main()
//{
//    test();//函数里开辟了没有释放
//    while(1);
//}

//kaipi(char* a)
//{
//    a=(char*)malloc(100);
//}
//{
//    char *sp=NULL;
//    kaipi(sp);
//    strcpy(sp,"string copy");
//    printf(sp);//这个没有问题，但是上一行就崩溃了
//
//}
//首先一个空指针，地址什么都没有（0）
//然后复制了一个地址a，a也是空指针
//进入kaipi函数，函数开辟了一个空间，这个空间的地址只有a存着
//然后kaipi函数结束，指针a同时也没有了
//但是，开辟的空间没有释放，而没有指针指向这个空间，造成内存泄漏
//所以这样写有错
//而到strcy函数，这里sp是存放地址的，并没有开辟空间，所以不能存后面的东西
//如果开辟了空间，那么可以这样写
//下面一行没错


//返回栈空间地址的问题
//函数中开辟内存一般都放在栈空间中，此内存生命周期仅在函数内部有效，
//如果返回其地址，在函数外使用地址，就会造成非法访问，如果用static
//修饰就会改至静态空间中，地址有效，用动态内存分配，在free之前地址也有效
//char *test()
//{
//    char a[]="hello";//在前面修饰一个static就可以
//    //函数内变量分配在栈区，生命周期在函数运行结束就没了
//    int *a=(int*)malloc(40);
//    //这样子也可以，因为a动态分配，开辟在堆区，堆区不free一直存在
//    return a;
//}
//char try()
//{
//    char *p=NULL;
//    p=test();
//    printf(p);//应该打印除hello，但实际上什么都没有
//}
//int main()
//{
//    try();
//    return 0;
//}


//野指针
//定义p的时候没有初始化，p会随便指向一块空间
//下一行*p,把10赋给*p，*p本来就有内容，这时候再把东西放进去不可以
//{
//   int* p;
//   *p=10;
//   printf(p);
//}


//下面这个代码就是内存泄漏问题
//free一下就好
//*a就是p，所以是可以在p后面开辟空间的
//char *test(char **a)
//{
//    *a=(int*)malloc(40);
//}
//
//int main()
//{
//    char *p=NULL;
//    test(&p);
//    p=test();
//    printf(p);
//    //free(p);
//    return 0;
//}


{
    char *p=(char*)malloc(100);
    strcpy(p,"hello");
    free(p);//释放了，但是不会弄成空指针
    if (p != NULL)
    {
        strcpy(p,"world");
        printf(str);
    }
}
//可以输出world，但有问题
//把内存释放了，但是p指针依然不是空的可以联合之前写的,free之后还要置为NULL
//所以free没有把p置成空指针，还是指向原来开辟的位置，但是这块
//指向的内存已经被释放了，不属于我，但是我下面依然使用了它，非法访问内存
